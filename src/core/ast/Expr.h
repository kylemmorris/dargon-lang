/*
 * Dargon Programming Language
 * (C) Kyle Morris 2023 - See LICENSE.txt for license information
 * 
 * FILE: Expr.h
 * 
 * DESCRIPTION: This file is automatically generated by "tools/GenDargonStmtExpr.py". It includes all the expression classes.
 * 
 * SINCE: v0.1
 * 
 */ 
#ifndef DARGON_EXPR_H
#define DARGON_EXPR_H
#include <string>
#include <any>
#include "../lex/Token.h"

namespace dargon {

	//Forward declarations:
	class BinaryExpr;
	class GroupingExpr;
	class LiteralExpr;
	class UnaryExpr;

	class IVisitor {
	public:
		virtual std::string VisitBinaryExpr(BinaryExpr* binary) = 0;
		virtual std::string VisitGroupingExpr(GroupingExpr* grouping) = 0;
		virtual std::string VisitLiteralExpr(LiteralExpr* literal) = 0;
		virtual std::string VisitUnaryExpr(UnaryExpr* unary) = 0;
	};
	/**
	 * @brief The base class of all Expressions.
	 *
	*/
	class Expr {
	public:
		virtual std::string Accept(IVisitor* visitor) = 0;
	};

	class BinaryExpr : public Expr {
	public:
		Expr* left;
		Token op;
		Expr* right;
		BinaryExpr(Expr* left, Token op, Expr* right)
		: left(left), op(op), right(right) {}
		virtual std::string Accept(IVisitor* visitor) override {
			return visitor->VisitBinaryExpr(this);
		}
	};
	class GroupingExpr : public Expr {
	public:
		Expr* expression;
		GroupingExpr(Expr* expression)
		: expression(expression) {}
		virtual std::string Accept(IVisitor* visitor) override {
			return visitor->VisitGroupingExpr(this);
		}
	};
	class LiteralExpr : public Expr {
	public:
		std::any value;
		LiteralExpr(std::any value)
		: value(value) {}
		virtual std::string Accept(IVisitor* visitor) override {
			return visitor->VisitLiteralExpr(this);
		}
	};
	class UnaryExpr : public Expr {
	public:
		Token op;
		Expr* right;
		UnaryExpr(Token op, Expr* right)
		: op(op), right(right) {}
		virtual std::string Accept(IVisitor* visitor) override {
			return visitor->VisitUnaryExpr(this);
		}
	};
};
#endif