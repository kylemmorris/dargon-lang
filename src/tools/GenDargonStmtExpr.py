# Dargon Programming Language 
# (C) Kyle Morris 2023

# This utility will be used to generate the expression and statement structures.
# Output: Expr.h

# TODO: Make this a lot cleaner! It'll come with Python experience.

from io import TextIOWrapper

### ------------###
### DEFINITIONS ###
### ------------###

# The input expressions
baseName = 'Expr'
fname = '../core/ast/' + baseName + '.h'
exprs = [\
    'Binary$ Expr* left, Token op, Expr* right',\
    'Grouping$ Expr* expression',\
    'Literal$ std::any value',\
    'Unary$ Token op, Expr* right'\
]

### ------------###
###  FUNCTIONS  ###
### ------------###

# Prints the copywrite info
def printCopywrite(f: TextIOWrapper):
    cwrite = ['/*\n',\
                 ' * Dargon Programming Language\n',\
                 ' * (C) Kyle Morris 2023 - See LICENSE.txt for license information\n',\
                 ' * \n',\
                 f' * FILE: {baseName}.h\n',\
                 ' * \n',\
                 ' * DESCRIPTION: This file is automatically generated by "tools/GenDargonStmtExpr.py". It includes all the expression classes.\n',\
                 ' * \n',\
                 ' * SINCE: v0.1\n',\
                 ' * \n',\
                 ' */ \n']
    f.writelines(cwrite)

# Prints the include lines
def printMacros(f: TextIOWrapper):
    cwrite = [f'#ifndef DARGON_{baseName.upper()}_H\n',\
              f'#define DARGON_{baseName.upper()}_H\n',\
              '#include <string>\n',\
              '#include <any>\n',\
              '#include "../lex/Token.h"\n\n',\
              'namespace dargon {\n'
              ]
    f.writelines(cwrite)

# Prints forward declarations and IVisitor interface
def printForwardDecl(f: TextIOWrapper, names :list[str]):
    f.write('\n\t//Forward declarations:\n')
    for name in names:
        f.write(f'\tclass {name+baseName};\n')
    f.write('\n\tclass IVisitor {\n\tpublic:\n')
    for name in names:
        f.write(f'\t\tvirtual std::string Visit{name+baseName}({name+baseName}* {name.lower()}) = 0;\n')
    f.write('\t};\n')

# Prints the base class
def printBaseClass(f: TextIOWrapper):
    comment = ['\t/**\n',\
              '\t * @brief The base class of all Expressions.\n',\
              '\t *\n',\
              '\t*/\n'\
              ]
    f.writelines(comment)
    f.write(f'\tclass {baseName} {{\n')
    f.write('\tpublic:\n\t\tvirtual std::string Accept(IVisitor* visitor) = 0;\n')
    f.write('\t};\n')

# Given a class, defines the public members of that class
# Since C++ doesn't have C#'s "get{}" or Java's "final",
# we simply provide a constant public member that is set in the 
# constructor.
def defineMembers(f: TextIOWrapper, fields: list[str]):
    for field in fields:
        vtype = field.strip().split()[0]
        vname = field.strip().split()[1]
        f.write(f'\t\t{vtype} {vname};\n')

# Creates a new subtype with:
# class name : public base {
# public:
#   const type1 field1;
#   const type2 field2;
#   name(type1 field1, type2 field2)
#   : type1(type1), type2(type2) {}
# };
def createExprSubclass(f: TextIOWrapper, name: str, fields: list[str]):
    f.write(f'\n\tclass {name+baseName} : public {baseName} ')
    f.write('{\n\tpublic:\n')
    defineMembers(f, fields)
    f.write(f'\t\t{name+baseName}(')
    firsts = fields[:len(fields)-1]
    end = fields[len(fields)-1]
    #print(firsts)
    #print(end)
    # Build the constructor parameter list
    for field in firsts:
        vtype = field.strip().split()[0]
        vname = field.strip().split()[1]
        f.write(f'{vtype} {vname}, ')
    if end != []:
        vtype = end.strip().split()[0]
        vname = end.strip().split()[1]
        f.write(f'{vtype} {vname}')
    f.write(')\n\t\t: ')
    # Build the initializer list
    for field in firsts:
        vtype = field.strip().split()[0]
        vname = field.strip().split()[1]
        f.write(f'{vname}({vname}), ')
    if end != []:
        vtype = end.strip().split()[0]
        vname = end.strip().split()[1]
        f.write(f'{vname}({vname}) {{}}')
    # Override the 'Accept' method
    f.write(f'\n\t\tvirtual std::string Accept(IVisitor* visitor) override {{\n')
    f.write(f'\t\t\treturn visitor->Visit{name+baseName}(this);\n')
    f.write('\t\t}\n\t};')
    #f.write(f'\n\
    #        \tvirtual std::string Accept(IVisitor* visitor) override {{ \n\
    #        \t\treturn visitor->Visit{name+baseName}(this);\
    #        \n\t}};'\
    #        ) 

# Prints the ending stuff
def printEnd(f: TextIOWrapper):
    f.write('\n};\n#endif')

### ------------###
### MAIN        ###
### ------------###

with open(fname, 'w') as fref:
    # Print copywrite info
    printCopywrite(fref)
    # Print #define/include macros
    printMacros(fref)
    # Grab all the names and values
    names = []
    fields = []
    for expr in exprs:
        names.append(expr.split('$')[0].strip())
        fields.append(expr.split('$')[1].strip())
    # Print forward declarations + visitor interface
    printForwardDecl(fref, names)
    # Print the base class
    printBaseClass(fref)
    # Create a subclass for every input
    for i, name in enumerate(names):
        createExprSubclass(fref, name, \
                            fields[i].split(',')\
                            )
    printEnd(fref)
    
