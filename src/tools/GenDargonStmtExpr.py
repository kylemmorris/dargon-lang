# Dargon Programming Language 
# (C) Kyle Morris 2023

# This utility will be used to generate the expression and statement structures.
# Output: Expr.h

# TODO: Make this a lot cleaner! It'll come with Python experience.

from io import TextIOWrapper

### ------------###
### DEFINITIONS ###
### ------------###

# The file name
fname = '../core/Expr.h'

# The input expressions
exprs = [\
    'Binary: Expr* left, Token op, Expr* right',\
    'Grouping: Expr* expression',\
    'Literal: void* value',\
    'Unary: Token op, Expr* right'\
]

### ------------###
###  FUNCTIONS  ###
### ------------###

# Prints the copywrite info
def printCopywrite(f: TextIOWrapper):
    cwrite = ['/*\n',\
                 ' * Dargon Programming Language\n',\
                 ' * (C) Kyle Morris 2023 - See LICENSE.txt for license information\n',\
                 ' * \n',\
                 ' * FILE: Expr.h\n',\
                 ' * \n',\
                 ' * DESCRIPTION: This file is automatically generated by "tools/GenDargonStmtExpr.py". It includes all the expression classes.\n',\
                 ' * \n',\
                 ' * SINCE: v0.1\n',\
                 ' * \n',\
                 ' */ \n']
    f.writelines(cwrite)

# Prints the include lines
def printIncludes(f: TextIOWrapper):
    f.write('#ifndef DARGON_EXPR_H\n')
    f.write('#define DARGON_EXPR_H\n\n')
    f.write('#include <string>\n')
    f.write('#include "Token.h"\n\n')

# This function generates the visitor interface we're using
def defineVisitorInterface(f: TextIOWrapper, base: str, types: list[str]):
    f.write('\ttemplate<typename T>\n')    
    f.write('\tclass IVisitor {\n')
    for t in types:
        f.write(f'\t\tvirtual T Visit{t}{base}({t}* {base.lower()}) = 0;\n')
    f.write('\t};')

# Prints the base class
def printBaseClass(f: TextIOWrapper, name: str):
    f.write('namespace dargon {\n\n')
    comment = ['\t/**\n',\
              '\t * @brief The base class of all Expressions.\n',\
              '\t *\n',\
              '\t*/\n'\
              ]
    f.writelines(comment)
    f.write('\t')
    f.write(f'class {name}')
    f.write(' {\n')
    f.write('\t\ttemplate<typename T>\n')
    f.write('\t\tvirtual T Accept(IVisitor<T>* visitor) = 0;\n')
    f.write('\t};\n\n')

# Given a class, defines the public members of that class
# Since C++ doesn't have C#'s "get{}" or Java's "final",
# we simply provide a constant public member that is set in the 
# constructor.
def defineMembers(f: TextIOWrapper, fields: list[str]):
    for field in fields:
        vtype = field.strip().split()[0]
        vname = field.strip().split()[1]
        f.write(f'\t\tconst {vtype} {vname};\n')

# Creates a new subtype with:
# class name : public base {
# public:
#   const type1 field1;
#   const type2 field2;
#   name(type1 field1, type2 field2)
#   : type1(type1), type2(type2) {}
# };
def createExprSubclass(f: TextIOWrapper, base: str, name: str, fields: list[str]):
    f.write(f'\tclass {name} : public {base} ')
    f.write('{\n\tpublic:\n')
    defineMembers(f, fields)
    f.write(f'\t\t{name}(')
    firsts = fields[:len(fields)-1]
    end = fields[len(fields)-1]
    #print(firsts)
    #print(end)
    # Build the constructor parameter list
    for field in firsts:
        vtype = field.strip().split()[0]
        vname = field.strip().split()[1]
        f.write(f'{vtype} {vname}, ')
    if end != []:
        vtype = end.strip().split()[0]
        vname = end.strip().split()[1]
        f.write(f'{vtype} {vname}')
    f.write(')\n\t\t: ')
    # Build the initializer list
    for field in firsts:
        vtype = field.strip().split()[0]
        vname = field.strip().split()[1]
        f.write(f'{vname}({vname}), ')
    if end != []:
        vtype = end.strip().split()[0]
        vname = end.strip().split()[1]
        f.write(f'{vname}({vname})')
    f.write('{}\n'
    # Override the 'Accept' method
    f.write('virtual ')
    f.write('\t};\n')
    

# Prints the ending stuff
def printEnd(f: TextIOWrapper):
    f.write('\n};\n#endif')

### ------------###
### MAIN        ###
### ------------###

with open(fname, 'w') as fref:
    printCopywrite(fref)
    base = 'Expr'
    printIncludes(fref)
    printBaseClass(fref, base)
    for expr in exprs:
        name = expr.split(':')[0]
        fields = expr.split(':')[1].split(',')
        createExprSubclass(fref, base, name, fields)
        fref.write('\n')
    types = []    
    for expr in exprs:
        types.append(expr.split(':')[0])
    defineVisitorInterface(fref, base, types)
    printEnd(fref)
